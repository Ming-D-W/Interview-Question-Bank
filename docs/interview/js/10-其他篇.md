---
title: JavaScript其他篇
---

## 十、其他篇

本篇包含Proxy、Reflect、严格模式等其他重要知识点。

### Proxy和Reflect

**Proxy**

Proxy用于创建一个对象的代理，可以拦截并自定义对象的基本操作（如属性查找、赋值等）。Vue 3的响应式系统就是基于Proxy实现的。

```js
const obj = { name: '张三', age: 18 }

const proxy = new Proxy(obj, {
  // 拦截读取操作
  get(target, key) {
    console.log(`读取了${key}属性`)
    return target[key]
  },
  // 拦截赋值操作
  set(target, key, value) {
    console.log(`设置了${key}属性为${value}`)
    target[key] = value
    return true
  },
  // 拦截删除操作
  deleteProperty(target, key) {
    console.log(`删除了${key}属性`)
    delete target[key]
    return true
  },
  // 拦截in操作符
  has(target, key) {
    console.log(`判断是否有${key}属性`)
    return key in target
  }
})

proxy.name // 输出：读取了name属性
proxy.age = 20 // 输出：设置了age属性为20
delete proxy.age // 输出：删除了age属性
'name' in proxy // 输出：判断是否有name属性
```

**Reflect**

Reflect是一个内置对象，提供了拦截JavaScript操作的方法。这些方法与Proxy的handler方法一一对应。

```js
const obj = { name: '张三', age: 18 }

// 读取属性
Reflect.get(obj, 'name') // "张三"

// 设置属性
Reflect.set(obj, 'age', 20) // true

// 删除属性
Reflect.deleteProperty(obj, 'age') // true

// 判断属性是否存在
Reflect.has(obj, 'name') // true

// 获取对象的所有属性名
Reflect.ownKeys(obj) // ['name']
```

**Proxy vs Object.defineProperty**

这是Vue 2和Vue 3响应式原理的区别：

| 特性 | Object.defineProperty | Proxy |
|------|----------------------|-------|
| 监听属性 | 需要遍历对象的每个属性 | 直接监听整个对象 |
| 监听数组 | 无法监听数组的变化 | 可以监听数组的变化 |
| 添加/删除属性 | 无法监听 | 可以监听 |
| 性能 | 初始化时需要遍历所有属性 | 惰性监听，性能更好 |
| 兼容性 | 兼容IE9+ | 不兼容IE |

### 严格模式

**什么是严格模式？**

严格模式是ES5引入的一种运行模式，通过在脚本或函数开头添加`'use strict'`来启用。严格模式消除了JavaScript语法的一些不合理、不严谨之处，减少了一些怪异行为。

**如何启用？**

```js
// 全局严格模式
'use strict'

// 函数级严格模式
function fn() {
  'use strict'
  // ...
}
```

**严格模式的限制：**

1. 变量必须声明后使用
```js
'use strict'
x = 10 // 报错：x is not defined
```

2. 禁止使用with语句
```js
'use strict'
with (obj) { } // 报错
```

3. 禁止this指向全局对象
```js
'use strict'
function fn() {
  console.log(this) // undefined
}
fn()
```

4. 禁止删除变量
```js
'use strict'
var x = 1
delete x // 报错
```

5. 对象不能有重复的属性名
```js
'use strict'
const obj = { a: 1, a: 2 } // 报错
```

6. 函数不能有重复的参数名
```js
'use strict'
function fn(a, a) { } // 报错
```

7. 禁止八进制表示法
```js
'use strict'
const num = 0123 // 报错
```

8. arguments对象不再追踪参数变化
```js
'use strict'
function fn(a) {
  a = 2
  console.log(arguments[0]) // 1（非严格模式下是2）
}
fn(1)
```

### 性能优化

**代码层面优化：**

1. **防抖节流**：减少高频事件触发的次数
2. **图片懒加载**：使用Intersection Observer API
3. **虚拟滚动**：只渲染可视区域的内容
4. **Web Worker**：将耗时计算放到worker线程
5. **requestAnimationFrame**：优化动画性能
6. **事件委托**：减少事件监听器数量
7. **减少重排重绘**：批量修改DOM，使用documentFragment
8. **使用CSS动画代替JS动画**：硬件加速

**资源优化：**

1. **代码分割**：按需加载，减少首屏加载时间
2. **Tree Shaking**：移除未使用的代码
3. **压缩代码**：使用terser等工具压缩JS
4. **图片优化**：使用webp格式，压缩图片
5. **CDN加速**：静态资源使用CDN
6. **开启Gzip压缩**：减小传输体积
7. **浏览器缓存**：合理设置缓存策略
8. **预加载/预连接**：使用link标签的rel属性

**打包优化：**

1. **缩小打包体积**：使用生产模式打包
2. **splitChunks**：提取公共代码
3. **externals**：外部依赖不打包
4. **DLL**：预编译依赖库
5. **happypack/thread-loader**：多线程打包

### 跨域解决方案

**什么是跨域？**

跨域是指浏览器出于安全考虑，实施的同源策略限制。当协议、域名、端口任一不同时，都会产生跨域。

**同源策略限制：**
- 无法读取Cookie、LocalStorage、SessionStorage
- 无法操作DOM
- AJAX请求无法发送

**跨域解决方案：**

#### 1. JSONP（只支持GET请求）

原理：利用script标签不受同源策略限制的特性。

```js
// 前端代码
function jsonpCallback(data) {
  console.log('获取到数据:', data)
}

const script = document.createElement('script')
script.src = 'http://example.com/api?callback=jsonpCallback'
document.body.appendChild(script)

// 服务器返回
// jsonpCallback({ name: '张三', age: 18 })

// 封装JSONP
function jsonp(url, callback) {
  return new Promise((resolve, reject) => {
    const callbackName = 'jsonp_' + Date.now()
    window[callbackName] = (data) => {
      resolve(data)
      delete window[callbackName]
      document.body.removeChild(script)
    }
    const script = document.createElement('script')
    script.src = `${url}?callback=${callbackName}`
    script.onerror = reject
    document.body.appendChild(script)
  })
}

// 使用
jsonp('http://example.com/api').then(data => {
  console.log(data)
})
```

#### 2. CORS（跨域资源共享）

服务器设置响应头，允许跨域请求。

```js
// Node.js (Express) 服务端设置
app.use((req, res, next) => {
  // 允许的源
  res.header('Access-Control-Allow-Origin', '*') // 或指定域名
  // 允许的请求方法
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS')
  // 允许的请求头
  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization')
  // 允许携带Cookie
  res.header('Access-Control-Allow-Credentials', 'true')
  // 预检请求缓存时间
  res.header('Access-Control-Max-Age', '86400')

  if (req.method === 'OPTIONS') {
    res.sendStatus(200)
  } else {
    next()
  }
})

// 前端携带Cookie
fetch('http://example.com/api', {
  credentials: 'include' // 携带Cookie
})
```

#### 3. 代理服务器

开发环境使用webpack devServer代理，生产环境使用Nginx反向代理。

```js
// webpack.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://example.com', // 目标服务器
        changeOrigin: true, // 修改请求头中的host
        pathRewrite: {
          '^/api': '' // 重写路径
        }
      }
    }
  }
}

// 前端请求
fetch('/api/users') // 实际请求: http://example.com/users
```

```nginx
## Nginx配置
server {
  listen 80;
  server_name localhost;

  location /api {
    proxy_pass http://example.com;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
  }
}
```

#### 4. postMessage（窗口通信）

用于不同窗口之间的跨域通信。

```js
// 父窗口向子窗口发送消息
const iframe = document.getElementById('myIframe')
iframe.contentWindow.postMessage('Hello from parent', 'http://example.com')

// 子窗口接收消息
window.addEventListener('message', (e) => {
  // 验证来源
  if (e.origin !== 'http://parent.com') return

  console.log('收到消息:', e.data)

  // 回复消息
  e.source.postMessage('Hello from child', e.origin)
})
```

#### 5. WebSocket

WebSocket不受同源策略限制。

```js
const socket = new WebSocket('ws://example.com')

socket.onopen = () => {
  console.log('连接成功')
  socket.send('Hello Server')
}

socket.onmessage = (e) => {
  console.log('收到消息:', e.data)
}
```

#### 6. document.domain（主域相同的情况）

```js
// a.example.com页面
document.domain = 'example.com'

// b.example.com页面
document.domain = 'example.com'

// 现在可以互相访问了
```

#### 7. window.name

```js
// a.html
window.name = 'data from a.html'
location.href = 'b.html'

// b.html
console.log(window.name) // 'data from a.html'
```

### Ajax 和 Fetch

#### Ajax（XMLHttpRequest）

```js
// 创建XMLHttpRequest对象
const xhr = new XMLHttpRequest()

// 配置请求
xhr.open('GET', '/api/users', true) // 方法、URL、是否异步

// 设置请求头
xhr.setRequestHeader('Content-Type', 'application/json')

// 监听状态变化
xhr.onreadystatechange = function() {
  // readyState:
  // 0: 未初始化
  // 1: 正在加载
  // 2: 加载完成
  // 3: 交互中
  // 4: 完成
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      console.log('成功:', xhr.responseText)
    } else {
      console.log('失败:', xhr.status)
    }
  }
}

// 监听进度
xhr.upload.onprogress = function(e) {
  if (e.lengthComputable) {
    const percent = (e.loaded / e.total) * 100
    console.log(`上传进度: ${percent}%`)
  }
}

// 发送请求
xhr.send(JSON.stringify({ name: '张三' }))

// 取消请求
// xhr.abort()

// 封装Ajax
function ajax(options) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest()
    const { method = 'GET', url, data, headers = {} } = options

    xhr.open(method, url, true)

    // 设置请求头
    Object.keys(headers).forEach(key => {
      xhr.setRequestHeader(key, headers[key])
    })

    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(JSON.parse(xhr.responseText))
        } else {
          reject(new Error(xhr.statusText))
        }
      }
    }

    xhr.onerror = function() {
      reject(new Error('Network Error'))
    }

    xhr.send(data ? JSON.stringify(data) : null)
  })
}

// 使用
ajax({
  method: 'POST',
  url: '/api/users',
  data: { name: '张三', age: 18 },
  headers: { 'Content-Type': 'application/json' }
}).then(res => {
  console.log('成功:', res)
}).catch(err => {
  console.log('失败:', err)
})
```

#### Fetch API

```js
// 基本用法
fetch('/api/users')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    return response.json()
  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error))

// POST请求
fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ name: '张三', age: 18 })
})
  .then(response => response.json())
  .then(data => console.log(data))

// 携带Cookie
fetch('/api/users', {
  credentials: 'include' // same-origin | include | omit
})

// 设置超时
const controller = new AbortController()
const timeoutId = setTimeout(() => controller.abort(), 5000)

fetch('/api/users', {
  signal: controller.signal
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('请求超时')
    }
  })
  .finally(() => clearTimeout(timeoutId))

// 上传文件
const formData = new FormData()
formData.append('file', fileInput.files[0])
formData.append('name', '张三')

fetch('/api/upload', {
  method: 'POST',
  body: formData
})
  .then(response => response.json())
  .then(data => console.log(data))

// async/await写法
async function getUsers() {
  try {
    const response = await fetch('/api/users')
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    const data = await response.json()
    console.log(data)
  } catch (error) {
    console.error('Error:', error)
  }
}
```

#### Ajax vs Fetch

| 特性 | Ajax (XMLHttpRequest) | Fetch |
|------|----------------------|-------|
| 语法 | 回调函数 | Promise |
| 浏览器兼容性 | 兼容性好 | 不支持IE |
| 超时控制 | 内置timeout | 需要AbortController |
| 上传进度 | 支持 | 不支持 |
| 错误处理 | 状态码错误会触发error | 只有网络错误才reject |
| Cookie | 默认携带 | 需要配置credentials |
| 取消请求 | abort() | AbortController |

### Symbol详解

**什么是Symbol？**

Symbol是ES6新增的原始数据类型，表示独一无二的值，主要用于对象属性名，避免属性名冲突。

**基本用法：**

```js
// 创建Symbol
const s1 = Symbol()
const s2 = Symbol()
console.log(s1 === s2) // false

// 带描述的Symbol
const s3 = Symbol('mySymbol')
console.log(s3.toString()) // 'Symbol(mySymbol)'
console.log(s3.description) // 'mySymbol'

// 作为对象属性
const obj = {
  [s3]: 'value'
}
console.log(obj[s3]) // 'value'
console.log(obj.s3) // undefined (不能用点语法访问)

// Symbol属性不会被常规遍历
const obj2 = {
  name: '张三',
  [Symbol('age')]: 18,
  [Symbol('gender')]: '男'
}

Object.keys(obj2) // ['name']
Object.getOwnPropertyNames(obj2) // ['name']
for (let key in obj2) { console.log(key) } // name

// 获取Symbol属性
Object.getOwnPropertySymbols(obj2) // [Symbol(age), Symbol(gender)]
Reflect.ownKeys(obj2) // ['name', Symbol(age), Symbol(gender)]
```

**Symbol.for() 和 Symbol.keyFor()：**

```js
// Symbol.for(): 全局注册
const s1 = Symbol.for('foo')
const s2 = Symbol.for('foo')
console.log(s1 === s2) // true (共享同一个Symbol)

// Symbol.keyFor(): 获取Symbol的key
const s3 = Symbol.for('bar')
console.log(Symbol.keyFor(s3)) // 'bar'

const s4 = Symbol('baz')
console.log(Symbol.keyFor(s4)) // undefined (不是通过Symbol.for创建的)
```

**内置Symbol值：**

```js
// Symbol.iterator: 对象的迭代器
const arr = [1, 2, 3]
const iterator = arr[Symbol.iterator]()
console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.next()) // { value: 3, done: false }
console.log(iterator.next()) // { value: undefined, done: true }

// 自定义迭代器
const obj = {
  data: ['a', 'b', 'c'],
  [Symbol.iterator]() {
    let index = 0
    return {
      next: () => {
        if (index < this.data.length) {
          return { value: this.data[index++], done: false }
        } else {
          return { done: true }
        }
      }
    }
  }
}

for (let item of obj) {
  console.log(item) // 'a' 'b' 'c'
}

// Symbol.toStringTag: 自定义toString()的返回值
class MyClass {
  get [Symbol.toStringTag]() {
    return 'MyClass'
  }
}
const instance = new MyClass()
console.log(Object.prototype.toString.call(instance)) // '[object MyClass]'

// Symbol.hasInstance: 自定义instanceof行为
class MyArray {
  static [Symbol.hasInstance](instance) {
    return Array.isArray(instance)
  }
}
console.log([] instanceof MyArray) // true
console.log({} instanceof MyArray) // false
```

**使用场景：**

1. 对象属性名，避免冲突
2. 定义类的私有属性和方法
3. 消除魔术字符串（代码中多次出现的特定字符串）

```js
// 消除魔术字符串
// 不好的写法
function getArea(shape) {
  if (shape === 'triangle') {
    return 'triangle'
  }
  if (shape === 'circle') {
    return 'circle'
  }
}

// 好的写法
const shapeType = {
  triangle: Symbol('triangle'),
  circle: Symbol('circle')
}

function getArea(shape) {
  if (shape === shapeType.triangle) {
    return shapeType.triangle
  }
  if (shape === shapeType.circle) {
    return shapeType.circle
  }
}
```

### 迭代器（Iterator）和生成器（Generator）

#### 迭代器（Iterator）

**什么是迭代器？**

迭代器是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了Iterator接口，就可以完成遍历操作。

**迭代器协议：**

```js
// 迭代器对象必须有next()方法
// next()方法返回: { value: 当前值, done: 是否完成 }

// 手动实现迭代器
function createIterator(arr) {
  let index = 0
  return {
    next() {
      if (index < arr.length) {
        return { value: arr[index++], done: false }
      } else {
        return { value: undefined, done: true }
      }
    }
  }
}

const iterator = createIterator([1, 2, 3])
console.log(iterator.next()) // { value: 1, done: false }
console.log(iterator.next()) // { value: 2, done: false }
console.log(iterator.next()) // { value: 3, done: false }
console.log(iterator.next()) // { value: undefined, done: true }
```

**可迭代对象：**

部署了`Symbol.iterator`属性的对象就是可迭代对象。

```js
// 原生具备Iterator接口的数据结构
// - Array
// - String
// - Set
// - Map
// - TypedArray
// - 函数的arguments对象
// - NodeList对象

// 自定义可迭代对象
const iterable = {
  data: ['a', 'b', 'c'],
  [Symbol.iterator]() {
    let index = 0
    const data = this.data
    return {
      next() {
        if (index < data.length) {
          return { value: data[index++], done: false }
        } else {
          return { done: true }
        }
      }
    }
  }
}

// 使用for...of遍历
for (let item of iterable) {
  console.log(item) // 'a' 'b' 'c'
}

// 使用扩展运算符
console.log([...iterable]) // ['a', 'b', 'c']

// 使用Array.from
console.log(Array.from(iterable)) // ['a', 'b', 'c']
```

#### 生成器（Generator）

**什么是生成器？**

生成器是ES6提供的一种异步编程解决方案，可以理解为一个状态机，封装了多个内部状态。

**基本语法：**

```js
// 生成器函数
function* gen() {
  yield 1
  yield 2
  yield 3
  return 4
}

const g = gen()
console.log(g.next()) // { value: 1, done: false }
console.log(g.next()) // { value: 2, done: false }
console.log(g.next()) // { value: 3, done: false }
console.log(g.next()) // { value: 4, done: true }
console.log(g.next()) // { value: undefined, done: true }

// for...of遍历（不包括return的值）
for (let item of gen()) {
  console.log(item) // 1 2 3
}
```

**yield表达式：**

```js
function* gen() {
  const a = yield 1
  console.log('a:', a)
  const b = yield 2
  console.log('b:', b)
  return 3
}

const g = gen()
console.log(g.next()) // { value: 1, done: false }
console.log(g.next('参数A')) // 打印: a: 参数A, 返回: { value: 2, done: false }
console.log(g.next('参数B')) // 打印: b: 参数B, 返回: { value: 3, done: true }
```

**Generator实现异步操作：**

```js
// 模拟异步操作
function* asyncGenerator() {
  console.log('开始')

  const data1 = yield fetch('/api/user')
  console.log('用户数据:', data1)

  const data2 = yield fetch(`/api/posts/${data1.id}`)
  console.log('文章数据:', data2)

  return '完成'
}

// 自动执行器
function run(gen) {
  const g = gen()

  function next(data) {
    const result = g.next(data)
    if (result.done) return result.value
    result.value.then(response => response.json()).then(data => {
      next(data)
    })
  }

  next()
}

run(asyncGenerator)

// Generator vs async/await
// async/await就是Generator的语法糖
// 上面的代码用async/await改写：
async function asyncFunction() {
  console.log('开始')

  const response1 = await fetch('/api/user')
  const data1 = await response1.json()
  console.log('用户数据:', data1)

  const response2 = await fetch(`/api/posts/${data1.id}`)
  const data2 = await response2.json()
  console.log('文章数据:', data2)

  return '完成'
}
```

**Generator应用：**

```js
// 1. 无限序列
function* fibonacci() {
  let [prev, curr] = [0, 1]
  while (true) {
    yield curr;
    [prev, curr] = [curr, prev + curr]
  }
}

const fib = fibonacci()
console.log(fib.next().value) // 1
console.log(fib.next().value) // 1
console.log(fib.next().value) // 2
console.log(fib.next().value) // 3
console.log(fib.next().value) // 5

// 2. 状态机
function* stateMachine() {
  while (true) {
    yield 'A'
    yield 'B'
    yield 'C'
  }
}

const state = stateMachine()
console.log(state.next().value) // 'A'
console.log(state.next().value) // 'B'
console.log(state.next().value) // 'C'
console.log(state.next().value) // 'A'

// 3. 协程（控制流程）
function* gen1() {
  yield 1
  yield* gen2() // 委托给另一个生成器
  yield 4
}

function* gen2() {
  yield 2
  yield 3
}

for (let item of gen1()) {
  console.log(item) // 1 2 3 4
}
```


### 无感知登录

无感知登录是指在用户token过期后，自动刷新token并重新发起请求，用户无需重新登录。

**实现思路：**

1. **请求拦截器**：在请求头中添加token
2. **响应拦截器**：
   - 如果返回401（token过期），调用刷新token接口
   - 刷新成功后，重新发起之前失败的请求
   - 刷新失败，跳转到登录页

**示例代码：**

```js
// axios拦截器实现
let isRefreshing = false // 是否正在刷新token
let requests = [] // 存储待重发的请求

axios.interceptors.response.use(
  response => response,
  async error => {
    const { config, response } = error

    // token过期
    if (response?.status === 401) {
      if (!isRefreshing) {
        isRefreshing = true

        try {
          // 刷新token
          const { data } = await refreshToken()
          localStorage.setItem('token', data.token)

          // 重发所有待处理的请求
          requests.forEach(cb => cb(data.token))
          requests = []

          // 重发当前请求
          return axios(config)
        } catch (err) {
          // 刷新失败，跳转登录页
          router.push('/login')
          return Promise.reject(err)
        } finally {
          isRefreshing = false
        }
      } else {
        // 正在刷新token，将请求加入队列
        return new Promise(resolve => {
          requests.push(token => {
            config.headers.Authorization = `Bearer ${token}`
            resolve(axios(config))
          })
        })
      }
    }

    return Promise.reject(error)
  }
)
```

**优化方案：**

1. **使用双token机制**：accessToken（短期）+ refreshToken（长期）
2. **token即将过期时主动刷新**：避免请求失败
3. **限制刷新次数**：防止无限循环
4. **安全存储token**：使用httpOnly cookie存储refreshToken
---
title: JavaScript基础篇
---

## 一、基础篇

本篇涵盖JavaScript的基础知识，包括数据类型、变量声明、作用域、执行机制等核心概念。

### 数据类型

JavaScript有8种数据类型：

**基本数据类型（7种）**
- Number（数字）
- String（字符串）
- Boolean（布尔）
- Undefined（未定义）
- Null（空）
- Symbol（符号，ES6新增）
- BigInt（大整数，ES2020新增）

**引用数据类型（1种）**
- Object（对象），包括：Object、Array、Function、Date、RegExp、Map、Set等

**区别：**
1. 存储位置不同：基本类型存储在栈中，引用类型存储在堆中，栈中存储的是引用地址
2. 赋值方式不同：基本类型赋值是值的拷贝，引用类型赋值是地址的拷贝
3. 比较方式不同：基本类型比较值，引用类型比较地址

### 数据类型判断

**1. typeof**

可以判断基本数据类型（除了null），但对于引用类型，除了function返回"function"，其他都返回"object"。

```js
typeof 123 // "number"
typeof '123' // "string"
typeof true // "boolean"
typeof undefined // "undefined"
typeof null // "object" (历史遗留bug)
typeof Symbol() // "symbol"
typeof 10n // "bigint"
typeof {} // "object"
typeof [] // "object"
typeof function(){} // "function"
```

**2. instanceof**

用于判断对象的具体类型，检查构造函数的prototype是否在对象的原型链上。

```js
[] instanceof Array // true
[] instanceof Object // true
{} instanceof Object // true
function(){} instanceof Function // true
```

**3. Object.prototype.toString.call()**

最准确的类型判断方法，可以判断所有数据类型。

```js
Object.prototype.toString.call(123) // "[object Number]"
Object.prototype.toString.call('123') // "[object String]"
Object.prototype.toString.call(true) // "[object Boolean]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call({}) // "[object Object]"
Object.prototype.toString.call([]) // "[object Array]"
Object.prototype.toString.call(function(){}) // "[object Function]"
Object.prototype.toString.call(new Date()) // "[object Date]"
Object.prototype.toString.call(/\d/) // "[object RegExp]"
```

**4. Array.isArray()**

专门用于判断是否为数组。

```js
Array.isArray([]) // true
Array.isArray({}) // false
```

### 类型转换

**隐式类型转换**

JavaScript在运算过程中会自动进行类型转换。

```js
// 转为字符串
1 + '2' // "12"
'5' + 1 // "51"

// 转为数字
'5' - 2 // 3
'5' * '2' // 10
'5' / 2 // 2.5
'5' % 2 // 1

// 转为布尔值
!!0 // false
!!'hello' // true
if ('hello') {} // true

// == 运算符的隐式转换
null == undefined // true
0 == false // true
'' == false // true
[] == false // true
[] == ![] // true (复杂的转换规则)
```

**显式类型转换**

```js
// 转为字符串
String(123) // "123"
(123).toString() // "123"

// 转为数字
Number('123') // 123
parseInt('123px') // 123
parseFloat('12.3.4') // 12.3
+'123' // 123 (一元加运算符)

// 转为布尔值
Boolean(0) // false
Boolean('hello') // true

// 假值（转为布尔值为false的值）
// false, 0, '', null, undefined, NaN
```

### 变量声明

**var、let、const的区别：**

1. **作用域不同**
   - var声明的变量作用域是函数级别的
   - let和const声明的变量作用域是块级别的（可以是函数、花括号或模块）

```js
// var - 函数作用域
function test() {
  if (true) {
    var a = 1
  }
  console.log(a) // 1，可以访问
}

// let - 块级作用域
function test2() {
  if (true) {
    let b = 2
  }
  console.log(b) // 报错：b is not defined
}
```

2. **变量提升不同**
   - var声明的变量可以在声明之前访问，值为undefined
   - let和const声明的变量在声明之前访问会抛出ReferenceError

```js
console.log(a) // undefined
var a = 10

console.log(b) // 报错：Cannot access 'b' before initialization
let b = 20
```

3. **重复声明**
   - var声明的变量可以被重复声明
   - let和const声明的变量不允许重复声明

```js
var a = 1
var a = 2 // 正常

let b = 1
let b = 2 // 报错：Identifier 'b' has already been declared
```

4. **重新赋值**
   - var和let声明的变量可以被重新赋值
   - const声明的变量是不可变的，其值不能被重新赋值

```js
let a = 1
a = 2 // 正常

const b = 1
b = 2 // 报错：Assignment to constant variable
```

5. **初始化要求**
   - const声明的变量必须在声明时初始化，不能在之后赋值

```js
const a // 报错：Missing initializer in const declaration
const b = 1 // 正常
```

### 变量提升

**什么是变量提升？**

变量提升（Hoisting）是JavaScript在编译阶段将变量和函数声明提升到作用域顶部的行为。

**var的变量提升：**

```js
console.log(a) // undefined (不会报错)
var a = 10
console.log(a) // 10

// 相当于：
var a
console.log(a) // undefined
a = 10
console.log(a) // 10
```

**函数提升：**

```js
// 函数声明：完整提升
sayHi() // '你好' (可以在声明前调用)
function sayHi() {
  console.log('你好')
}

// 函数表达式：只提升变量，不提升函数
// sayHello() // 报错：sayHello is not a function
var sayHello = function() {
  console.log('Hello')
}
sayHello() // 'Hello'

// 相当于：
var sayHello // 变量提升
sayHello() // undefined() 报错
sayHello = function() {
  console.log('Hello')
}
```

**let和const没有变量提升：**

```js
// console.log(a) // 报错：Cannot access 'a' before initialization
let a = 10
console.log(a) // 10

// console.log(b) // 报错：Cannot access 'b' before initialization
const b = 20
console.log(b) // 20
```

**函数优先提升：**

当函数声明和变量声明同名时，函数声明优先级更高。

```js
console.log(foo) // [Function: foo]

var foo = 10
function foo() {
  console.log('foo')
}

console.log(foo) // 10

// 相当于：
function foo() {
  console.log('foo')
}
var foo // 重复声明被忽略
console.log(foo) // [Function: foo]
foo = 10
console.log(foo) // 10
```




### 暂时性死区

**什么是暂时性死区？**

暂时性死区（Temporal Dead Zone，简称TDZ）是指在let/const声明之前，该变量都是不可用的，访问会抛出ReferenceError错误。

```js
// TDZ开始
console.log(a) // 报错：Cannot access 'a' before initialization
let a = 10
// TDZ结束
console.log(a) // 10
```

**为什么会有TDZ？**

TDZ的设计是为了让程序更加严谨，减少运行时错误，提前发现问题。

**TDZ的特点：**

1. let/const声明的变量在声明之前都处于TDZ中
2. 在TDZ中访问变量会抛出错误
3. typeof检查也会报错

```js
// 情况1：var不存在TDZ
console.log(typeof a) // 'undefined'
var a = 10

// 情况2：let存在TDZ
console.log(typeof b) // 报错：Cannot access 'b' before initialization
let b = 10

// 情况3：未声明的变量
console.log(typeof c) // 'undefined' (不会报错)
```

**注意事项：**

```js
let x = 10
{
  // TDZ开始
  console.log(x) // 报错，不会访问外层的x
  let x = 20 // TDZ结束
}
```

### 作用域链

**什么是作用域链？**

作用域链是JavaScript中变量查找的机制。当访问一个变量时，JavaScript引擎会按照作用域链从内到外查找变量。

**查找规则：**

内部函数访问变量时：
1. 先在自身作用域查找变量声明
2. 如果没有找到，往外层作用域查找
3. 一直查找到全局作用域
4. 如果找到多个同名变量，采取就近原则

```js
const a = 'global'

function outer() {
  const a = 'outer'

  function inner() {
    const a = 'inner'
    console.log(a) // 'inner' - 就近原则
  }

  inner()
  console.log(a) // 'outer'
}

outer()
console.log(a) // 'global'
```

### 执行上下文

**什么是执行上下文？**

执行上下文（Execution Context）是JavaScript代码执行的环境，包含了变量、函数声明、作用域链、this等信息。

**执行上下文的类型：**

1. **全局执行上下文**：默认的、最基础的执行上下文，只有一个
2. **函数执行上下文**：每当函数被调用时，都会创建一个新的执行上下文
3. **Eval执行上下文**：eval函数内部的代码（不推荐使用）

**执行上下文的生命周期：**

1. **创建阶段**
   - 创建变量对象（Variable Object）
   - 建立作用域链（Scope Chain）
   - 确定this的指向

2. **执行阶段**
   - 变量赋值
   - 函数引用
   - 执行其他代码

3. **销毁阶段**
   - 执行完毕后，执行上下文被弹出执行栈并销毁

### 执行栈

**什么是执行栈？**

执行栈（Execution Stack），也叫调用栈（Call Stack），是JavaScript中用于存储代码执行顺序的数据结构。

**执行栈的特点：**

1. **后进先出（LIFO）**：最后添加的函数最先执行完毕
2. **单线程**：JavaScript是单线程的，同一时间只能执行一个任务
3. **栈溢出**：递归调用过深会导致栈溢出错误

**执行流程：**

```js
function first() {
  console.log('first函数开始')
  second()
  console.log('first函数结束')
}

function second() {
  console.log('second函数开始')
  third()
  console.log('second函数结束')
}

function third() {
  console.log('third函数执行')
}

first()

// 执行栈变化：
// 1. [first] - first入栈
// 2. [first, second] - second入栈
// 3. [first, second, third] - third入栈
// 4. [first, second] - third执行完出栈
// 5. [first] - second执行完出栈
// 6. [] - first执行完出栈

// 输出顺序：
// first函数开始
// second函数开始
// third函数执行
// second函数结束
// first函数结束
```

**栈溢出示例：**

```js
function recursion() {
  recursion() // 无限递归
}

recursion() // 报错：Maximum call stack size exceeded
```

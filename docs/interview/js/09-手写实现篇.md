---
title: JavaScript手写实现篇
---

## 九、手写实现篇

本篇包含常见的手写实现题目。

### 手写call

```js
Function.prototype.myCall = function(context, ...args) {
  // 判断context是否传入，如果未传入则设置为window
  context = context || window
  // 将调用函数设为对象的方法
  const fn = Symbol('fn')
  context[fn] = this
  // 执行该函数
  const result = context[fn](...args)
  // 删除该函数
  delete context[fn]
  // 返回结果
  return result
}
```

#### 手写apply

```js
Function.prototype.myApply = function(context, args) {
  context = context || window
  const fn = Symbol('fn')
  context[fn] = this
  const result = context[fn](...args)
  delete context[fn]
  return result
}
```

#### 手写bind

```js
Function.prototype.myBind = function(context, ...args1) {
  const fn = this
  return function(...args2) {
    return fn.apply(context, [...args1, ...args2])
  }
}
```

#### 手写new

```js
function myNew(constructor, ...args) {
  // 1. 创建一个空对象
  const obj = {}
  // 2. 将对象的__proto__指向构造函数的prototype
  obj.__proto__ = constructor.prototype
  // 3. 将构造函数的this指向obj，并执行构造函数
  const result = constructor.apply(obj, args)
  // 4. 如果构造函数返回的是对象，则返回该对象，否则返回obj
  return result instanceof Object ? result : obj
}
```

#### 手写instanceof

```js
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left)
  // 获取构造函数的prototype
  const prototype = right.prototype

  // 判断构造函数的prototype是否在对象的原型链上
  while (true) {
    if (!proto) return false
    if (proto === prototype) return true
    // 如果没有找到，就继续从其原型上找
    proto = Object.getPrototypeOf(proto)
  }
}
```

#### 手写Promise

```js
class MyPromise {
  constructor(executor) {
    this.state = 'pending'
    this.value = undefined
    this.reason = undefined
    this.onFulfilledCallbacks = []
    this.onRejectedCallbacks = []

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled'
        this.value = value
        this.onFulfilledCallbacks.forEach(fn => fn())
      }
    }

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = reason
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }

    try {
      executor(resolve, reject)
    } catch (error) {
      reject(error)
    }
  }

  then(onFulfilled, onRejected) {
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }

    const promise2 = new MyPromise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value)
            resolve(x)
          } catch (error) {
            reject(error)
          }
        })
      }

      if (this.state === 'rejected') {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason)
            resolve(x)
          } catch (error) {
            reject(error)
          }
        })
      }

      if (this.state === 'pending') {
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value)
              resolve(x)
            } catch (error) {
              reject(error)
            }
          })
        })

        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason)
              resolve(x)
            } catch (error) {
              reject(error)
            }
          })
        })
      }
    })

    return promise2
  }

  catch(onRejected) {
    return this.then(null, onRejected)
  }

  finally(callback) {
    return this.then(
      value => MyPromise.resolve(callback()).then(() => value),
      reason => MyPromise.resolve(callback()).then(() => { throw reason })
    )
  }

  static resolve(value) {
    return new MyPromise((resolve) => resolve(value))
  }

  static reject(reason) {
    return new MyPromise((resolve, reject) => reject(reason))
  }

  static all(promises) {
    return new MyPromise((resolve, reject) => {
      const result = []
      let count = 0
      promises.forEach((promise, index) => {
        MyPromise.resolve(promise).then(value => {
          result[index] = value
          count++
          if (count === promises.length) {
            resolve(result)
          }
        }, reject)
      })
    })
  }

  static race(promises) {
    return new MyPromise((resolve, reject) => {
      promises.forEach(promise => {
        MyPromise.resolve(promise).then(resolve, reject)
      })
    })
  }
}
```

#### 手写深拷贝

```js
function deepClone(obj, map = new WeakMap()) {
  // 处理null和undefined
  if (obj === null || obj === undefined) return obj

  // 处理基本数据类型
  if (typeof obj !== 'object') return obj

  // 处理日期对象
  if (obj instanceof Date) return new Date(obj)

  // 处理正则对象
  if (obj instanceof RegExp) return new RegExp(obj)

  // 处理循环引用
  if (map.has(obj)) return map.get(obj)

  // 根据原型创建新对象
  const cloneObj = new obj.constructor()
  map.set(obj, cloneObj)

  // 递归拷贝
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], map)
    }
  }

  return cloneObj
}
```

#### 手写防抖

```js
function debounce(fn, delay) {
  let timer = null
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}
```

#### 手写节流

```js
// 时间戳版本
function throttle(fn, delay) {
  let lastTime = 0
  return function(...args) {
    const now = Date.now()
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 定时器版本
function throttle(fn, delay) {
  let timer = null
  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
      }, delay)
    }
  }
}
```

#### 手写柯里化

```js
function curry(fn) {
  return function curried(...args) {
    // 如果参数够了，就执行函数
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    } else {
      // 否则返回一个函数，继续接收参数
      return function(...args2) {
        return curried.apply(this, args.concat(args2))
      }
    }
  }
}

// 使用示例
function add(a, b, c) {
  return a + b + c
}
const curriedAdd = curry(add)
console.log(curriedAdd(1)(2)(3)) // 6
console.log(curriedAdd(1, 2)(3)) // 6
console.log(curriedAdd(1, 2, 3)) // 6
```

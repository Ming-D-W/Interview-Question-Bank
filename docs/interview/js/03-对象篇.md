---
title: JavaScript对象篇
---

## 三、对象篇

本篇介绍JavaScript的面向对象编程，包括new关键字、原型链、继承、class等。

### new关键字的执行过程

使用`new`关键字调用构造函数时，JavaScript会自动执行以下步骤：

1. **创建一个新的空对象**
   ```js
   const obj = {}
   ```

2. **将新对象的`__proto__`指向构造函数的`prototype`**
   ```js
   obj.__proto__ = Constructor.prototype
   ```

3. **将构造函数内部的`this`指向新对象**
   ```js
   Constructor.call(obj)
   ```

4. **执行构造函数，给新对象添加属性和方法**
   构造函数内部的代码会被执行，所有`this.xxx`都会添加到新对象上

5. **返回新对象（默认return this）**
   - 如果构造函数没有返回值，或返回的是基本数据类型（Number、String、Boolean等），则返回新创建的对象
   - 如果构造函数返回的是对象类型（Object、Array、Function等），则返回该对象，new出来的对象会被丢弃

**示例：**

```js
function Person(name, age) {
  this.name = name
  this.age = age
  this.sayHi = function() {
    console.log(`我是${this.name}`)
  }
}

const p1 = new Person('张三', 18)
console.log(p1.name) // '张三'
console.log(p1.age) // 18
p1.sayHi() // '我是张三'

// 情况1: 返回基本类型，会被忽略
function Person1(name) {
  this.name = name
  return 123 // 返回基本类型，会被忽略
}
const p2 = new Person1('李四')
console.log(p2) // Person1 { name: '李四' }

// 情况2: 返回对象类型，会覆盖new创建的对象
function Person2(name) {
  this.name = name
  return { age: 20 } // 返回对象类型
}
const p3 = new Person2('王五')
console.log(p3) // { age: 20 }，name属性丢失
```

### 原型链

每个对象都有一个`__proto__`属性，指向其构造函数的`prototype`对象。这样就形成了一条原型链。

```js
function Person(name) {
  this.name = name
}

Person.prototype.sayHi = function() {
  console.log(`我是${this.name}`)
}

const p = new Person('张三')

// 原型链：p -> Person.prototype -> Object.prototype -> null
console.log(p.__proto__ === Person.prototype) // true
console.log(Person.prototype.__proto__ === Object.prototype) // true
console.log(Object.prototype.__proto__) // null
```

**原型链的作用：**
- 实现继承
- 实现属性和方法的共享

**属性查找规则：**
1. 先在对象自身查找
2. 如果没有，沿着原型链向上查找
3. 直到找到或到达原型链顶端（null）

### 继承

JavaScript中实现继承的几种方式：

**1. 原型链继承**

```js
function Parent() {
  this.name = '父类'
}

Parent.prototype.getName = function() {
  return this.name
}

function Child() {}

Child.prototype = new Parent()

const child = new Child()
console.log(child.getName()) // '父类'
```

**缺点：**
- 所有实例共享父类的引用类型属性
- 无法向父类构造函数传参

**2. 构造函数继承**

```js
function Parent(name) {
  this.name = name
}

function Child(name) {
  Parent.call(this, name)
}

const child = new Child('子类')
console.log(child.name) // '子类'
```

**缺点：**
- 无法继承父类原型上的方法
- 每次创建实例都会创建一遍方法

**3. 组合继承（最常用）**

```js
function Parent(name) {
  this.name = name
}

Parent.prototype.getName = function() {
  return this.name
}

function Child(name, age) {
  Parent.call(this, name) // 继承属性
  this.age = age
}

Child.prototype = new Parent() // 继承方法
Child.prototype.constructor = Child

const child = new Child('张三', 18)
console.log(child.getName()) // '张三'
console.log(child.age) // 18
```

**4. ES6 class继承**

```js
class Parent {
  constructor(name) {
    this.name = name
  }

  getName() {
    return this.name
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name)
    this.age = age
  }
}

const child = new Child('张三', 18)
console.log(child.getName()) // '张三'
```

### class类

ES6引入了class关键字，使得面向对象编程更加清晰。

```js
// 基本用法
class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  sayHi() {
    console.log(`我是${this.name}`)
  }

  static create(name, age) {
    return new Person(name, age)
  }
}

const p = new Person('张三', 18)
p.sayHi() // '我是张三'

// 类的继承
class Student extends Person {
  constructor(name, age, grade) {
    super(name, age)
    this.grade = grade
  }

  sayHi() {
    console.log(`我是${this.name}，我在${this.grade}年级`)
  }
}

const s = new Student('小明', 15, 3)
s.sayHi() // '我是小明，我在3年级'
```

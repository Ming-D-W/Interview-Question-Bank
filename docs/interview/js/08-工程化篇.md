---
title: JavaScript工程化篇
---

## 八、工程化篇

本篇介绍前端工程化相关的知识点，包括数据处理、性能优化、错误处理等。

### 数组转树形结构

**方法一：递归函数**

```js
function transArrToTree(list,pid) {
  const arr = []
  list.forEach(item => {
    if(item.pid === pid) {
      item.children = transArrToTree(list,item.id)
      arr.push(item)
    }
  })
  return arr
}
```

**方法二：map映射**

```js
export function transListToTreeUseMap(list) {
  const arr = []
  const map = {}
  list.forEach(item => {
    item.children = []
    map[item.id] = item
  })
  list.forEach(item => {
    if (map[item.pid]) {
      map[item.pid].children.push(item)
    } else {
      arr.push(item)
    }
  })
  return arr
}
```

**实现思路：**

1. 首先定义一个空数组 `arr` 和一个空对象 `map`。
2. 遍历传入的列表 `list`，为每个节点添加一个空的 `children` 数组，并将节点对象以 `id` 为键，以节点对象本身为值，存入 `map` 对象中。
3. 再次遍历传入的列表 `list`，对于每个节点，如果其父节点在 `map` 对象中存在，则将该节点添加到其父节点的 `children` 数组中；否则，将该节点添加到 `arr` 数组中。
4. 最后返回 `arr` 数组，即为转换后的树形结构数据。

这段代码的主要思路是利用一个对象 `map` 来存储每个节点对象，以便在后续遍历中快速查找其父节点，并将其添加到父节点的 `children` 数组中。

### 树形扁平化转数组

**递归函数实现：**

```js
function dataFattening (data) {
  const arr = []
  data.forEach(item => {
    if(item.children?.length) {
      arr = [ ...arr, ...dataFattening(item.children) ]
    } else {
      arr.push(item)
    }
  })
  return arr
}
```

**实现思路：**

1. 定义一个空数组 `arr`。
2. 遍历传入的树形结构数据 `data`，对于每个节点，判断其是否有子节点，如果有，则递归调用 `dataFattening` 函数，将子节点扁平化后合并到 `arr` 数组中；否则，将该节点直接添加到 `arr` 数组中。
3. 最后返回 `arr` 数组，即为扁平化后的数据。

这段代码的主要思路是利用递归函数将嵌套的树形结构数据转换成扁平化的数组。在递归过程中，对于每个节点，如果它有子节点，则递归调用函数处理子节点，并将子节点扁平化后的结果合并到当前节点的扁平化结果中。如果当前节点没有子节点，则直接将当前节点添加到扁平化结果中。

**注意：** 在这段代码中使用了可选链操作符 `?.`，它用于判断一个对象是否有某个属性或方法，如果有则返回该属性或方法的值，否则返回 `undefined`。这样可以避免在访问不存在的属性或方法时出现报错，提高代码的健壮性。

### 深拷贝

**浅拷贝 vs 深拷贝：**

**浅拷贝**：只复制对象的第一层属性，如果属性值是引用类型，则复制的是引用地址。

```js
// 浅拷贝的几种方式
const arr1 = [1, 2, 3]
const arr2 = arr1.slice()
const arr3 = arr1.concat()
const arr4 = [...arr1]
```

**深拷贝**：递归复制对象的所有层级，创建一个完全独立的新对象。

**深拷贝的实现方式：**

```js
// 1. JSON方法（简单但有限制）
const obj1 = { a: 1, b: { c: 2 } }
const obj2 = JSON.parse(JSON.stringify(obj1))

// 限制：
// - 无法复制函数、undefined、Symbol
// - 无法处理循环引用
// - 会丢失Date对象、RegExp对象

// 2. 递归实现深拷贝
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return obj
  if (obj instanceof Date) return new Date(obj)
  if (obj instanceof RegExp) return new RegExp(obj)
  if (typeof obj !== 'object') return obj

  // 处理循环引用
  if (hash.has(obj)) return hash.get(obj)

  const cloneObj = new obj.constructor()
  hash.set(obj, cloneObj)

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash)
    }
  }
  return cloneObj
}

// 3. 使用lodash库
// const obj2 = _.cloneDeep(obj1)
```

### 防抖节流

**防抖（Debounce）**：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

**应用场景：**
- 搜索框输入联想
- 窗口resize事件
- 表单验证

```js
function debounce(fn, delay) {
  let timer = null
  return function(...args) {
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 使用
const handleInput = debounce(function(e) {
  console.log('搜索:', e.target.value)
}, 500)
```

**节流（Throttle）**：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

**应用场景：**
- 滚动加载
- 按钮点击
- 鼠标移动

```js
function throttle(fn, delay) {
  let lastTime = 0
  return function(...args) {
    const now = Date.now()
    if (now - lastTime >= delay) {
      fn.apply(this, args)
      lastTime = now
    }
  }
}

// 使用
const handleScroll = throttle(function() {
  console.log('滚动事件触发')
}, 1000)
```

**区别：**
- 防抖：多次触发，只执行最后一次
- 节流：多次触发，按固定频率执行

### 内存泄漏

内存泄漏是指程序中已分配的内存由于某种原因未释放或无法释放，造成系统内存的浪费。

**常见的内存泄漏场景：**

1. **意外的全局变量**
```js
function foo() {
  bar = '意外的全局变量' // 没有用var/let/const声明
}
```

2. **被遗忘的定时器**
```js
const timer = setInterval(() => {
  // 一些操作
}, 1000)
// 忘记clearInterval(timer)
```

3. **闭包引用**
```js
function outer() {
  const largeData = new Array(1000000)
  return function inner() {
    console.log(largeData.length)
  }
}
const fn = outer() // largeData一直被引用，无法释放
```

4. **DOM引用**
```js
const elements = []
function addElement() {
  const div = document.createElement('div')
  elements.push(div) // 即使div从DOM中移除，仍被引用
}
```

5. **事件监听器未移除**
```js
const element = document.getElementById('button')
element.addEventListener('click', onClick)
// 忘记removeEventListener
```

**如何避免内存泄漏：**
- 及时清除定时器
- 移除事件监听器
- 避免不必要的全局变量
- 合理使用闭包
- 及时清除DOM引用

### 事件委托&事件冒泡

**事件冒泡（Event Bubbling）**

事件冒泡是指当一个元素上触发某个事件时，该事件会从该元素开始向上冒泡到祖先元素，直到到达文档根节点。在事件冒泡过程中，可以通过事件对象的target属性来获取当前触发事件的元素。

事件冒泡机制的优点是可以在父元素上统一处理多个子元素的事件，从而减少代码量和提高性能。同时，也可以方便地通过事件委托来实现动态绑定和解绑事件处理程序的需求。但是，如果不加以控制，事件冒泡也可能会导致意外的事件触发和处理，从而影响应用程序的稳定性和可靠性。因此，在实际应用中需要谨慎使用事件冒泡和事件委托技术，合理控制事件的传播和处理。

**事件委托（Event Delegation）**

事件委托是一种常见的优化技巧，它利用了事件的冒泡机制来减少事件处理程序的数量。事件委托的核心思想是将事件处理程序绑定到父元素上，而不是绑定到每个子元素上。当子元素上触发事件时，事件会冒泡到父元素，由父元素上的事件处理程序来处理。

例如，如果我们需要对一个列表中的每个项绑定点击事件，我们可以绑定一个事件处理程序到列表的父元素上，然后通过事件委托来处理每个子元素的点击事件。这样就可以避免在每个子元素上都绑定一个事件处理程序，从而提高性能和代码的可维护性。

**示例代码：**

```js
// 不使用事件委托
const items = document.querySelectorAll('.item')
items.forEach(item => {
  item.addEventListener('click', function() {
    console.log('点击了', this.textContent)
  })
})

// 使用事件委托
const list = document.querySelector('.list')
list.addEventListener('click', function(e) {
  if (e.target.classList.contains('item')) {
    console.log('点击了', e.target.textContent)
  }
})
```

### 前端如何捕获错误

**1. try-catch**

```js
try {
  // 可能出错的代码
  JSON.parse('invalid json')
} catch (error) {
  console.error('捕获到错误:', error)
}
```

**2. window.onerror**

```js
window.onerror = function(message, source, lineno, colno, error) {
  console.log('全局错误:', message)
  return true // 返回true阻止默认处理
}
```

**3. window.addEventListener('error')**

```js
window.addEventListener('error', (event) => {
  console.log('捕获到错误:', event.error)
}, true)
```

**4. Promise错误捕获**

```js
// Promise.catch
promise.catch(error => {
  console.error('Promise错误:', error)
})

// unhandledrejection事件
window.addEventListener('unhandledrejection', event => {
  console.error('未处理的Promise错误:', event.reason)
})
```

---
title: JavaScript异步篇
---

## 四、异步篇

本篇介绍JavaScript的异步编程机制，包括回调函数、Promise、async/await、事件循环等。

### 回调函数

**什么是回调函数？**

回调函数是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。

```js
// 基本示例
fs.readFile('/etc/passwd', function (err, data) {
  if (err) throw err
  console.log(data)
})

// 回调函数示例
function fetchData(callback) {
  setTimeout(() => {
    const data = { name: '张三', age: 18 }
    callback(data)
  }, 1000)
}

fetchData((data) => {
  console.log('获取到数据:', data)
})
```

**回调地狱问题：**

当多个异步操作存在依赖关系时，会形成回调地狱（Callback Hell），代码难以维护。

```js
// 回调地狱示例
getData1((data1) => {
  getData2(data1, (data2) => {
    getData3(data2, (data3) => {
      getData4(data3, (data4) => {
        console.log('最终结果:', data4)
      })
    })
  })
})
```

### Promise

Promise是ES6新增的异步编程解决方案，可以解决回调地狱问题，使异步代码更加优雅。

**Promise的三种状态：**
- **pending（进行中）**：初始状态，既不是成功也不是失败
- **fulfilled（已成功）**：操作成功完成
- **rejected（已失败）**：操作失败

状态一旦改变就不会再变，只能从pending变为fulfilled或从pending变为rejected。

**基本用法：**

```js
// 创建Promise
const promise = new Promise((resolve, reject) => {
  // 异步操作
  setTimeout(() => {
    const success = true
    if (success) {
      resolve('成功的结果') // 将状态改为fulfilled
    } else {
      reject('失败的原因') // 将状态改为rejected
    }
  }, 1000)
})

// 使用Promise
promise
  .then(result => {
    console.log(result) // '成功的结果'
    return result + ' 处理后'
  })
  .then(result => {
    console.log(result) // '成功的结果 处理后'
  })
  .catch(error => {
    console.log('捕获错误:', error)
  })
  .finally(() => {
    console.log('无论成功失败都会执行')
  })
```

**Promise链式调用：**

```js
// 解决回调地狱
getData1()
  .then(data1 => getData2(data1))
  .then(data2 => getData3(data2))
  .then(data3 => getData4(data3))
  .then(data4 => {
    console.log('最终结果:', data4)
  })
  .catch(error => {
    console.log('任何一步出错都会被捕获:', error)
  })
```

**Promise的静态方法：**

```js
// 1. Promise.all() - 所有Promise都成功才成功
const p1 = Promise.resolve(1)
const p2 = Promise.resolve(2)
const p3 = Promise.resolve(3)

Promise.all([p1, p2, p3]).then(results => {
  console.log(results) // [1, 2, 3]
})

// 只要有一个失败，就会立即reject
const p4 = Promise.reject('错误')
Promise.all([p1, p2, p4]).catch(error => {
  console.log(error) // '错误'
})

// 2. Promise.race() - 返回最先完成的Promise结果
const p5 = new Promise(resolve => setTimeout(() => resolve('慢'), 1000))
const p6 = new Promise(resolve => setTimeout(() => resolve('快'), 100))

Promise.race([p5, p6]).then(result => {
  console.log(result) // '快'
})

// 3. Promise.allSettled() - 等待所有Promise完成（无论成功失败）
const p7 = Promise.resolve(1)
const p8 = Promise.reject('错误')
const p9 = Promise.resolve(3)

Promise.allSettled([p7, p8, p9]).then(results => {
  console.log(results)
  // [
  //   { status: 'fulfilled', value: 1 },
  //   { status: 'rejected', reason: '错误' },
  //   { status: 'fulfilled', value: 3 }
  // ]
})

// 4. Promise.any() - 返回第一个成功的Promise
const p10 = Promise.reject('错误1')
const p11 = Promise.reject('错误2')
const p12 = Promise.resolve('成功')

Promise.any([p10, p11, p12]).then(result => {
  console.log(result) // '成功'
})

// 如果所有Promise都失败，返回AggregateError
Promise.any([p10, p11]).catch(error => {
  console.log(error) // AggregateError: All promises were rejected
})

// 5. Promise.resolve() - 将值转换为Promise
Promise.resolve('hello').then(value => {
  console.log(value) // 'hello'
})

// 6. Promise.reject() - 返回一个rejected状态的Promise
Promise.reject('错误').catch(error => {
  console.log(error) // '错误'
})
```

### async/await

async/await是ES2017引入的语法糖，基于Promise实现，使异步代码看起来像同步代码，更加直观易读。

**基本用法：**

```js
// async函数总是返回Promise
async function getData() {
  return '数据' // 相当于 return Promise.resolve('数据')
}

getData().then(data => console.log(data)) // '数据'

// await等待Promise完成
async function fetchData() {
  const promise = new Promise(resolve => {
    setTimeout(() => resolve('异步数据'), 1000)
  })

  const result = await promise // 等待Promise完成
  console.log(result) // '异步数据'
  return result
}

fetchData()
```

**错误处理：**

```js
// 使用try-catch捕获错误
async function fetchDataWithError() {
  try {
    const result = await Promise.reject('出错了')
    console.log(result)
  } catch (error) {
    console.log('捕获到错误:', error) // '捕获到错误: 出错了'
  }
}

// 不使用try-catch，错误会被返回的Promise捕获
async function fetchData2() {
  const result = await Promise.reject('出错了')
  return result
}

fetchData2().catch(error => {
  console.log('Promise捕获错误:', error)
})
```

**并发执行：**

```js
// 串行执行（耗时长）
async function serial() {
  const result1 = await fetch('/api/1') // 等待1秒
  const result2 = await fetch('/api/2') // 等待1秒
  const result3 = await fetch('/api/3') // 等待1秒
  // 总耗时: 3秒
}

// 并发执行（耗时短）
async function parallel() {
  const [result1, result2, result3] = await Promise.all([
    fetch('/api/1'),
    fetch('/api/2'),
    fetch('/api/3')
  ])
  // 总耗时: 1秒（同时发起请求）
}

// 使用Promise.all并发
async function fetchMultiple() {
  const urls = ['/api/1', '/api/2', '/api/3']
  const promises = urls.map(url => fetch(url))
  const results = await Promise.all(promises)
  return results
}
```

**实际应用示例：**

```js
// 顺序获取用户信息和订单信息
async function getUserData(userId) {
  try {
    // 1. 获取用户信息
    const user = await fetch(`/api/users/${userId}`).then(res => res.json())
    console.log('用户信息:', user)

    // 2. 根据用户ID获取订单
    const orders = await fetch(`/api/orders?userId=${userId}`).then(res => res.json())
    console.log('订单信息:', orders)

    // 3. 返回完整数据
    return { user, orders }
  } catch (error) {
    console.error('获取数据失败:', error)
    throw error
  }
}

// 使用
getUserData(123).then(data => {
  console.log('完整数据:', data)
})
```

**async/await vs Promise：**

```js
// Promise写法
function getDataPromise() {
  return fetch('/api/data')
    .then(response => response.json())
    .then(data => {
      console.log(data)
      return data
    })
    .catch(error => {
      console.error(error)
    })
}

// async/await写法（更清晰）
async function getDataAsync() {
  try {
    const response = await fetch('/api/data')
    const data = await response.json()
    console.log(data)
    return data
  } catch (error) {
    console.error(error)
  }
}
```

### 事件循环

JavaScript是单线程的，通过事件循环（Event Loop）机制来处理异步任务。

**执行流程：**
1. 同步任务在主线程上执行，形成执行栈
2. 异步任务的回调函数放入任务队列
3. 执行栈清空后，读取任务队列，将回调函数压入执行栈执行
4. 重复以上步骤

### 宏任务&微任务

**宏任务（Macro Task）：**
- setTimeout
- setInterval
- setImmediate（Node.js）
- I/O操作
- UI渲染

**微任务（Micro Task）：**
- Promise.then/catch/finally
- async/await
- MutationObserver
- process.nextTick（Node.js）

**执行顺序：**
1. 执行一个宏任务
2. 执行所有微任务
3. 渲染（如果需要）
4. 执行下一个宏任务

**示例代码：**

```js
console.log('1') // 同步任务

setTimeout(() => {
  console.log('2') // 宏任务
}, 0)

Promise.resolve().then(() => {
  console.log('3') // 微任务
})

console.log('4') // 同步任务

// 输出顺序：1 4 3 2
// 解释：
// 1. 执行同步任务：1, 4
// 2. 执行微任务：3
// 3. 执行宏任务：2
```

**复杂示例：**

```js
console.log('start')

setTimeout(() => {
  console.log('setTimeout1')
  Promise.resolve().then(() => {
    console.log('promise1')
  })
}, 0)

Promise.resolve().then(() => {
  console.log('promise2')
  setTimeout(() => {
    console.log('setTimeout2')
  }, 0)
})

console.log('end')

// 输出顺序：start end promise2 setTimeout1 promise1 setTimeout2
```

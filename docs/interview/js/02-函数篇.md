---
title: JavaScript函数篇
---

## 二、函数篇

本篇介绍JavaScript中函数的核心概念，包括this指向、call/apply/bind、箭头函数、闭包等。

### this指向

this的指向取决于函数的调用方式，而不是函数的定义位置。

**1. 默认绑定（独立函数调用）**
在非严格模式下，this指向全局对象（浏览器中是window）；在严格模式下，this是undefined。

```js
function fn() {
  console.log(this)
}
fn() // 非严格模式: window, 严格模式: undefined
```

**2. 隐式绑定（对象方法调用）**
当函数作为对象的方法调用时，this指向该对象。

```js
const obj = {
  name: '张三',
  sayName() {
    console.log(this.name)
  }
}
obj.sayName() // this指向obj，输出"张三"
```

**3. 显式绑定（call/apply/bind）**
通过call、apply、bind可以显式指定this的指向。

```js
function fn() {
  console.log(this.name)
}
const obj = { name: '李四' }
fn.call(obj) // this指向obj，输出"李四"
fn.apply(obj) // this指向obj，输出"李四"
const bindFn = fn.bind(obj)
bindFn() // this指向obj，输出"李四"
```

**4. new绑定（构造函数调用）**
使用new关键字调用构造函数时，this指向新创建的实例对象。

```js
function Person(name) {
  this.name = name
}
const person = new Person('王五')
console.log(person.name) // "王五"
```

**5. 箭头函数**
箭头函数没有自己的this，它的this继承自外层作用域，且无法通过call/apply/bind改变。

```js
const obj = {
  name: '赵六',
  sayName: () => {
    console.log(this.name) // this不是obj，而是外层作用域的this
  }
}
```

**优先级：** new绑定 > 显式绑定 > 隐式绑定 > 默认绑定

### call、apply、bind的区别

这三个方法都可以改变函数内部this的指向。

**call：**
- 立即调用函数
- 参数逐个传递

```js
function greet(age, city) {
  console.log(`我是${this.name}，今年${age}岁，来自${city}`)
}

const obj = { name: '张三' }
greet.call(obj, 18, '北京') // '我是张三，今年18岁，来自北京'
```

**apply：**
- 立即调用函数
- 参数以数组形式传递

```js
greet.apply(obj, [18, '北京']) // '我是张三，今年18岁，来自北京'
```

**bind：**
- 不立即调用，返回一个新函数
- 参数逐个传递

```js
const boundGreet = greet.bind(obj, 18, '北京')
boundGreet() // '我是张三，今年18岁，来自北京'
```

**区别总结：**
- call和apply立即执行，bind返回新函数
- call和bind参数逐个传递，apply参数以数组传递
- bind可以分步传参（柯里化）

### 箭头函数和普通函数的区别

1. **语法更简洁**
```js
// 普通函数
function add(a, b) {
  return a + b
}

// 箭头函数
const add = (a, b) => a + b
```

2. **没有自己的this**
箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。

```js
const obj = {
  name: '张三',
  sayName: function() {
    setTimeout(function() {
      console.log(this.name) // undefined，this指向window
    }, 100)
  },
  sayName2: function() {
    setTimeout(() => {
      console.log(this.name) // '张三'，this继承自外层
    }, 100)
  }
}
```

3. **不能作为构造函数**
箭头函数不能使用new关键字调用。

```js
const Person = (name) => {
  this.name = name
}
// new Person('张三') // 报错：Person is not a constructor
```

4. **没有arguments对象**
箭头函数没有自己的arguments对象，但可以使用rest参数。

```js
// 普通函数
function fn() {
  console.log(arguments) // [1, 2, 3]
}
fn(1, 2, 3)

// 箭头函数
const fn2 = (...args) => {
  console.log(args) // [1, 2, 3]
}
fn2(1, 2, 3)
```

5. **不能使用yield关键字**
箭头函数不能用作Generator函数。

### 默认参数

ES6允许为函数参数设置默认值。

```js
// 基本用法
function greet(name = '游客', age = 18) {
  console.log(`你好，${name}，今年${age}岁`)
}
greet() // '你好，游客，今年18岁'
greet('张三') // '你好，张三，今年18岁'
greet('李四', 20) // '你好，李四，今年20岁'

// 默认值可以是表达式
function getDefaultName() {
  return '默认用户'
}
function greet2(name = getDefaultName()) {
  console.log(name)
}

// 默认值可以引用其他参数
function add(x, y = x) {
  return x + y
}
add(5) // 10
```

### 闭包

**什么是闭包？**

闭包（Closure）是指有权访问另一个函数作用域中变量的函数。简单来说，闭包就是函数嵌套函数，内部函数可以访问外部函数的变量。

**闭包的特点：**

1. 函数嵌套函数
2. 内部函数可以访问外部函数的变量
3. 外部函数的变量不会被垃圾回收机制回收

**基本示例：**

```js
function outer() {
  const name = '张三'

  function inner() {
    console.log(name) // 访问外部函数的变量
  }

  return inner
}

const fn = outer()
fn() // '张三'
```

**闭包的应用场景：**

1. **数据私有化**

```js
function createCounter() {
  let count = 0 // 私有变量

  return {
    increment() {
      count++
      return count
    },
    decrement() {
      count--
      return count
    },
    getCount() {
      return count
    }
  }
}

const counter = createCounter()
console.log(counter.increment()) // 1
console.log(counter.increment()) // 2
console.log(counter.getCount()) // 2
console.log(counter.count) // undefined，无法直接访问
```

2. **函数柯里化**

```js
function add(a) {
  return function(b) {
    return a + b
  }
}

const add5 = add(5)
console.log(add5(3)) // 8
console.log(add5(10)) // 15
```

3. **延迟执行**

```js
function delay(fn, time) {
  return function(...args) {
    setTimeout(() => {
      fn.apply(this, args)
    }, time)
  }
}

const delayedLog = delay(console.log, 1000)
delayedLog('Hello') // 1秒后输出 'Hello'
```

4. **模块化**

```js
const module = (function() {
  let privateVar = '私有变量'

  function privateMethod() {
    console.log('私有方法')
  }

  return {
    publicMethod() {
      console.log('公共方法')
      privateMethod()
    },
    getPrivateVar() {
      return privateVar
    }
  }
})()

module.publicMethod() // '公共方法' '私有方法'
console.log(module.getPrivateVar()) // '私有变量'
console.log(module.privateVar) // undefined
```

**闭包的注意事项：**

1. **内存泄漏**：闭包会使外部函数的变量一直保存在内存中，如果使用不当可能导致内存泄漏

```js
function createClosure() {
  const largeData = new Array(1000000).fill('data')

  return function() {
    console.log(largeData[0])
  }
}

const fn = createClosure() // largeData一直被引用，无法释放
```

2. **循环中的闭包问题**

```js
// 错误示例
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i) // 输出5个5
  }, 100)
}

// 解决方案1：使用let
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i) // 输出0, 1, 2, 3, 4
  }, 100)
}

// 解决方案2：使用闭包
for (var i = 0; i < 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j) // 输出0, 1, 2, 3, 4
    }, 100)
  })(i)
}
```

